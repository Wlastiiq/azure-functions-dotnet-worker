// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
namespace Microsoft.Azure.Functions.Worker.Sdk.Generators
{
    /// <summary>
    /// Generates code a class with a method to return the startup type names and it's assembly names.
    /// Also generates an attribute to decorate the class with. 
    /// </summary>

    //  [AttributeUsage(AttributeTargets.Class)]
    //  public class ExtensionStartupDataAttribute : Attribute
    //  {
    //  }
    //  [ExtensionStartupData]
    //  internal sealed class ExtensionStartupTypeInfoProvider
    //  {
    //    public IDictionary<string, string> GetStartupTypes()
    //    {
    //        var dict = new Dictionary<string, string>(2);
    //        dict.Add("Microsoft.Azure.Functions.Worker.Extensions.CosmosDB.MyCosmosExtensionStartup", "Microsoft.Azure.Functions.Worker.Extensions.CosmosDB, Version=4.0.1.0, Culture=neutral, PublicKeyToken=551316b6919f366c");
    //        dict.Add("Microsoft.Azure.Functions.Worker.Extensions.Http.MyHttpExtensionStartup", "Microsoft.Azure.Functions.Worker.Extensions.Http, Version=4.0.5.0, Culture=neutral, PublicKeyToken=551316b6919f366c");
    //        return dict;
    //    }
    //  }

    [Generator]
    public class StartupLocatorSourceGenerator : ISourceGenerator
    {
        private string attributeFullTypeName = "Microsoft.Azure.Functions.Worker.Extensions.Abstractions.WorkerExtensionStartupAttribute";
        private string attributeClassName = "WorkerExtensionStartupAttribute";

        public void Execute(GeneratorExecutionContext context)
        {
            var typeAndAssemblyNamesDict = GetStatupTypeAndAssemblyMapping(context);

            if (!typeAndAssemblyNamesDict.Any())
            {
                return;
            }

            var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);

            SourceText sourceText;
            using (var stringWriter = new StringWriter())
            using (var indentedTextWriter = new IndentedTextWriter(stringWriter))
            {
                indentedTextWriter.WriteLine("// <auto-generated/>");
                indentedTextWriter.WriteLine("using System;");
                indentedTextWriter.WriteLine("using System.Collections.Generic;");
                indentedTextWriter.WriteLine($"namespace {mainMethod?.ContainingNamespace?.ToDisplayString() ?? "MyUnitTestNamespace"}");
                indentedTextWriter.WriteLine("{");
                indentedTextWriter.Indent++;
                WriteStartupDataProviderAttribute(indentedTextWriter);
                WriteStartupDataProviderClass(indentedTextWriter, typeAndAssemblyNamesDict);
                indentedTextWriter.Indent--;
                indentedTextWriter.WriteLine("}");

                indentedTextWriter.Flush();
                sourceText = SourceText.From(stringWriter.ToString(), encoding: Encoding.UTF8);
            }

            // Add the source code to the compilation
            context.AddSource($"ExtensionStartupDataProvider.g.cs", sourceText);
        }

        /// <summary>
        /// Gets the startup type name and it's assembly names in the form of a dictionary.
        /// The key will be the type name and value will be the assembly name.
        /// </summary>
        private IDictionary<string, string> GetStatupTypeAndAssemblyMapping(GeneratorExecutionContext context)
        {
            Dictionary<string, string> typeAndAssemblyDict = new();

            // find assemblies with "WorkerExtensionStartupAttribute".
            // Extension authors should decorate their assembly with this attribute if they want to take part in startup.
            var assemblies = context.Compilation.SourceModule.ReferencedAssemblySymbols
                                                .Where(s => s.GetAttributes()
                                                             .Any(a => a.AttributeClass?.Name == attributeClassName &&
                                                                       //Call GetFullName only if class name matches.
                                                                       a.AttributeClass.GetFullName() == attributeFullTypeName
                                                                    ));

            foreach (var assembly in assemblies)
            {
                var startupAttr = assembly.GetAttributes()
                                          .First(a => a.AttributeClass?.Name == attributeClassName &&
                                                      a.AttributeClass.GetFullName() == attributeFullTypeName);

                TypedConstant firstConstructorParam = startupAttr.ConstructorArguments[0];
                if (firstConstructorParam.Value is ITypeSymbol typeSymbol)
                {
                    var fullTypeName = typeSymbol.ToDisplayString();
                    var assemblyName = assembly.ToDisplayString();
                    typeAndAssemblyDict.Add(fullTypeName, assemblyName);
                }
            }

            return typeAndAssemblyDict;
        }

        private void WriteStartupDataProviderAttribute(IndentedTextWriter textWriter)
        {
            textWriter.WriteLine("[AttributeUsage(AttributeTargets.Class)]");
            textWriter.WriteLine("public class ExtensionStartupDataAttribute : Attribute");
            textWriter.WriteLine("{");
            textWriter.WriteLine("}");
        }

        private static void WriteStartupDataProviderClass(IndentedTextWriter textWriter, IDictionary<string, string> typeAndAssemblyDict)
        {
            textWriter.WriteLine("[ExtensionStartupData]");
            textWriter.WriteLine("internal sealed class ExtensionStartupTypeInfoProvider");
            textWriter.WriteLine("{");
            textWriter.Indent++;
            textWriter.WriteLine("public IDictionary<string, string> GetStartupTypes()");
            textWriter.WriteLine("{");
            textWriter.Indent++;
            textWriter.WriteLine($"var dict = new Dictionary<string, string>({typeAndAssemblyDict.Count});");

            foreach (var kp in typeAndAssemblyDict)
            {
                textWriter.WriteLine($"dict.Add(\"{kp.Key}\",\"{kp.Value}\");");
            }

            textWriter.WriteLine("return dict;");
            textWriter.Indent--;
            textWriter.WriteLine("}");
            textWriter.Indent--;
            textWriter.WriteLine("}");
        }

        public void Initialize(GeneratorInitializationContext context)
        {
        }
    }
}
